# PostgreSQL search implementation
Default search implementation in the FhirEST using PostgreSQL as the backing database. 
Module will automatically read conformance configuration and create needed table structure.  
For every StructureDefinition, a table (partition) will be created wil link to resource id.  
For every SearchParameter a separate table (partition) will be created with indexed values.  
Module detects changes of search parameters and starts (re)indexing of changed search parameters in the background.

## Dependencies

`pg-search` depends on the [pg-store](../pg-store) module to provide the underlying resource storage mechanisms.


## Installation
1. Add gradle dependency
```
implementation "ee.fhir.fhirest:fhirest-search:${fhirestVersion}"
```
2. Include changeset in main liquibase changelog
```
pg-search/changelog/changelog.xml
```

## Configuration
By default, `pg-store` module will use [pg-core](../pg-core) defined datasources.  
You can also define separate datasource and liquibase configurations with prefixes `search-app` and `search-admin`
```yml
spring:
  datasource:
    search-app:
      jdbc-url: jdbc:postgresql://localhost:5191/fhirestdb
      username: fhirest_app
      password: test
      maximum-pool-size: 10
      driver-class-name: org.postgresql.Driver
    search-admin:
      jdbc-url: jdbc:postgresql://localhost:5191/fhirestdb
      username: fhirest_admin
      password: test
      maximum-pool-size: 1
      driver-class-name: org.postgresql.Driver
      liquibase:
        change-log: 'classpath:changelog-search.xml'
        parameters:
          app-username: ${spring.datasource.search-app.username}
```


## Module overview and details
- Tables
    - `blindex` - managed by FhirEST. Stores information about indexes.
- Index tables
    - `resource` - reference to a stored resource. Partitioned by resource type
    - `base_index_date` - date datatype indexes
    - `base_index_number` - numeric datatype indexes
    - `base_index_quantity` - quantity datatype indexes
    - `base_index_reference` - reference datatype indexes
    - `base_index_string` - text datatype indexes
    - `base_index_token` - token datatype indexes
    - `base_index_uri` - uri datatype indexes

For every defined **SearchParameter** a partition of corresponding index table is created and information about this index is stored in `blindex`.

### Search mechanism
Every search run generates two database queries, one for counting total rows, another for actual paged data.
For every query parameter an `EXISTS` construction is built, referencing to specific index partition. Correct partition is found using **SearchParameter** definitions and `blindex` table.
Search returns a set of resource ids, which are then being loaded using `kefhir-store`.

- Example of search query
```bash
/Encounter?episode-of-care.patient:Patient.name=Alex&identifier=somesystem|123&practitioner=333&date=gt2022-01-01
```
- and related SQL generated by Search module
```sql
SELECT base.resource_id, rt.type resource_type FROM search.resource base
INNER JOIN search.resource_type rt on rt.id = base.resource_type

--chain episode-of-care.patient
INNER JOIN search.resource episodeofcare ON episodeofcare.resource_type = 53 AND episodeofcare.active = true
  AND EXISTS (SELECT 1 FROM search.encounter_reference_episodeofcare i WHERE i.active = true and i.sid = base.sid
    AND i.id = episodeofcare.resource_id AND i.type_id = episodeofcare.resource_type)
INNER JOIN search.resource patient ON patient.resource_type = 107 AND patient.active = true
  AND EXISTS (SELECT 1 FROM search.episodeofcare_reference_patient i WHERE i.active = true and i.sid = episodeofcare.sid
    AND i.id = patient.resource_id AND i.type_id = patient.resource_type)
    
-- patient.name = Alex
  AND EXISTS (SELECT 1 FROM search.patient_string_name i WHERE i.active = true and i.sid = patient.sid AND i.string ilike 'Alex%')
WHERE base.resource_type = 49 and base.active = true

-- date = gt2022-01-01
AND EXISTS (SELECT 1 FROM search.encounter_date_period i WHERE i.active = true and i.sid = base.sid AND i.range >> search.range('2022-01-01T00:00:00+02:00', '1 day'))

-- identifier = somesystem|123
AND EXISTS (SELECT 1 FROM search.encounter_token_identifier i WHERE i.active = true and i.sid = base.sid AND (i.value = '123' and i.system_id = search.sys_id('somesystem')))

-- practitioner = 333
AND EXISTS (SELECT 1 FROM search.encounter_reference_participant_individual i WHERE i.active = true and i.sid = base.sid AND (i.id = '333' and i.type_id = search.rt_id('Practitioner')))
```
